% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transformation.R
\name{clustering_dlc}
\alias{clustering_dlc}
\title{Daily load curves clustering}
\usage{
clustering_dlc(
  data,
  consumptionFeature,
  outdoorTemperatureFeature,
  localTimeZone,
  kMax,
  kMin,
  inputVars,
  loadCurveTransformation,
  nDayParts,
  balanceOutdoorTemperatures,
  nNeighboursAffinity = 7,
  ignoreDates = c(),
  holidaysDates = c(),
  normalisationMethod = "range01"
)
}
\arguments{
\item{data}{<data.frame> containing the time series for total energy
consumption of a building, the outdoor temperature, or whatever input is
needed for clustering.}

\item{consumptionFeature}{<string> containing the column name the consumption
feature  in the data argument.}

\item{outdoorTemperatureFeature}{<string> containing the column name of the
outdoor temperature feature in the data argument.}

\item{localTimeZone}{<string> specifying the local time zone related to the
building in analysis. The format of this time zones are defined by the IANA
Time Zone Database (https://www.iana.org/time-zones).}

\item{kMax}{<integer> defining the maximum number of allowed groups in
the clustering proceed.}

\item{kMin}{<integer> defining the minimum number of allowed groups in
the clustering proceed.}

\item{inputVars}{<list of strings> Select a number of features as an input
of the clustering.
  loadCurve: use the transformed version of the consumption daily load curve
    based on loadCurveTransformation and nDayParts arguments
  dailyTemperature: use the average daily outdoor temperature
  dailyConsumption: use the total daily consumption
  daysOfTheWeek: use a discrete value to represent the days of the week
  daysWeekend: use a boolean representing whether is weekend or not
  dailyHolidays: use a boolean representing whether is holiday or not.
  daysWeek: use a factorial value for each day of the week.
  loadCurves: loadCurves_columns, 
  month: use the month of the year,
  dailyMinConsumption: use the minimum consumption of the day
  dailyMaxConsumption: use the maximum consumption of the day}

\item{loadCurveTransformation}{<string> that defines the transformation
procedure over the consumption load curves. Possible values are:
  relative: All daily load curves are relative to their total daily
    consumption. It is the default mode.
  absolute: The absolute consumption is used to define each daily
    load curves.}

\item{nDayParts}{<integer> defining the parts of day used to. Possible
values: 24, 12, 8, 6, 4, 3, 2.}

\item{ignoreDates}{<list of dates> list of dates to ignore (holidays,
weather, ..)}
}
\value{
<list>
    dailyClassification <data.frame> in daily frequency, containing
the classification of each daily load curve.
    absoluteLoadCurvesCentroids <matrix> with row names as the
identifier of the cluster, and column names as the day hours. This matrix
is filled with the hourly average consumption of each cluster detected.
    clusteringCentroids <matrix> with row names as the identifier of
the cluster, and column names as the input variables used by the clustering
algorithm. This matrix is filled with the average values of each input
variable and cluster.
    classificationModel <object> containing a simple classification
model to predict a load curve based on calendar features.
    opts: <dictionary>
  normSpecs: matrix of aggregations used in the Z-score normalisation of
    the clustering inputs. The different types of aggregations (mean,
    median, std, ...) are specified as row names, and the different
    input features are related with column names.
  loadCurveTransformation: object
  inputVars: object
  nDayParts: object
}
\description{
Cluster similar daily load curves based on the load curves itself, calendar
variables and outdoor temperature
}
